# Client Code: Deconstructing a Python SL-API client  

Let's look at how to construct an SL-API client in python, from scratch.
For this purpose, we use the tutorial `route.py`. This tutorial showcases how to set up a connection to the IOS-XR Service-Layer over gRPC and manipulate IPv4 route entries in the IOS-XR RIB.  


Connect to devbox and drop into the python tutorials directory again:  

<p style="margin: 2em 0!important;padding: 1em;font-family: CiscoSans,Arial,Helvetica,sans-serif;font-size: 1em !important;text-indent: initial;background-color: #e6f2f7;border-radius: 5px;box-shadow: 0 1px 1px rgba(0,127,171,0.25);">**Username**: admin<br/>**Password**: admin<br/>**SSH port**: 2211
</p>  


```
$ ssh -p 2211 admin@10.10.20.170
admin@10.10.20.170's password:
Last login: Sat Sep  1 16:06:23 2018 from 192.168.122.1
admin@devbox:~$
admin@devbox:~$
admin@devbox:~$ cd ~/service-layer-objmodel/grpc/python/src/tutorial/
admin@devbox:tutorial$
admin@devbox:tutorial$ pwd
/home/admin/service-layer-objmodel/grpc/python/src/tutorial
admin@devbox:tutorial$
admin@devbox:tutorial$ ls -l route.py
-rw-rw-r-- 1 admin admin 12857 Aug 27 04:40 route.py
admin@devbox:tutorial$
admin@devbox:tutorial$

```


## Analyzing route.py

### Import required Python libraries    
Apart from the standard `os` and `sys` modules, we import the `ipaddress` module that would help work with IP addresses in python. We also import the `threading` module that we will use to run the initialization channel in the background.

```
#
# Copyright (c) 2016 by cisco Systems, Inc.
# All rights reserved.
#

# Standard python libs
import ipaddress
import os
import sys
import threading

```

### Import Required Service-Layer API Python bindings  

The python bindings that were generated earlier in this lab, are located under `/home/admin/service-layer-objmodel/grpc/python/src/genpy` while the tutorials are in `/home/admin/service-layer-objmodel/grpc/python/src/tutorial`. So include the path `/home/admin/service-layer-objmodel/grpc/python` in the PYTHONPATH before importing the service-layer API python bindings. We do this using the `sys` module here, but you could accomplish it by setting the `PYTHONPATH` environment variable as well, before running the script.

```
# Add the generated python bindings directory to the path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
```  

Now import the SL-API python bindings.

```
# gRPC generated python bindings
from genpy import sl_global_pb2_grpc
from genpy import sl_global_pb2
from genpy import sl_common_types_pb2
from genpy import sl_version_pb2
from genpy import sl_route_ipv4_pb2_grpc
from genpy import sl_route_ipv4_pb2
from genpy import sl_route_common_pb2

```
The Bindings imported are:


* **sl_global_pb2_grpc**: Used to set up the Global-Init gRPC stub (essentially a piece of code that handles encoding/decoding the objects  over the gRPC connection to for the Initialization Vertical).

* **sl_version_pb2**: Contains the current version number of the Service-Layer API supported by the router.

* **sl_global_pb2**: Used to set up the Init Message with the required version number (must match the version number specified in the Proto file: `sl_version.proto`) before using the Global-Init gRPC stub to initiate a connection.

* **sl_common_types_pb2**: Contains the data structures (messages) that are used to check error codes in the responses from the router allowing us to take necessary action.


* **sl_route_ipv4_pb2_grpc**: Used to set up the Route-IPv4 gRPC stub (to encode/decode objects related to the Route IPv4 vertical over the gRPC connection).  

* **sl_route_ipv4_pb2**: Used to set up the Routev4Msg which will contain a batch of IPv4 route objects that must be manipulated (Added/Updated/Deleted) in the IOS-XR RIB.  

* **sl_route_common_pb2**: Contains the data structures(messages) that are used to construct the Route-Vertical registration objects and  parts of the Route object.




### Import the gRPC library  

Post gRPC version=`1.0.0` (in this lab we are using `1.7.0`), the gRPC library can be imported as shown below:  

```
# gRPC libs
import grpc

```
For gRPC version&lt;`1.0.0`, the code examples utilize the gRPC beta implementation and these examples can be found under the `grpc_beta` folder. We will not spend time on the beta implementation code here.

```
admin@devbox:tutorial$ pwd
/home/admin/service-layer-objmodel/grpc/python/src/tutorial
admin@devbox:tutorial$
admin@devbox:tutorial$ ls -l ./grpc_beta/
total 44
-rw-rw-r-- 1 admin admin  5813 Aug 27 04:40 client_init.py
-rw-rw-r-- 1 admin admin     0 Aug 27 04:40 __init__.py
-rw-rw-r-- 1 admin admin 12650 Aug 27 04:40 interface.py
-rw-rw-r-- 1 admin admin  5008 Aug 27 04:40 mpls_ilm.py
-rw-rw-r-- 1 admin admin  5726 Aug 27 04:40 quickstart.py
-rw-rw-r-- 1 admin admin  3624 Aug 27 04:40 vrf.py
admin@devbox:tutorial$
```

### Utility to accept gRPC server IP and server port (Optional)

The `get_server_ip_port` code is of course optional, and you can use a variety of techniques to accept the gRPC SERVER_IP and SERVER_PORT arguments into the code. Here a simple snippet utilizing environment variables in the shell is shown:  

```
#
# Get the GRPC Server IP address and port number
#
def get_server_ip_port():
    # Get GRPC Server's IP from the environment
    if 'SERVER_IP' not in os.environ.keys():
        print("Need to set the SERVER_IP env variable e.g.")
        print("export SERVER_IP='10.30.110.214'")
        os._exit(0)

    # Get GRPC Server's Port from the environment
    if 'SERVER_PORT' not in os.environ.keys():
        print("Need to set the SERVER_PORT env variable e.g.")
        print("export SERVER_PORT='57777'")
        os._exit(0)

    return (os.environ['SERVER_IP'], int(os.environ['SERVER_PORT']))
```

### Set up Initialization Channel

We start off the code by defining a function to populate the Init Msg and set up the initialization channel using the relevant gRPC stub (passed in as a parameter). The other parameter (event) is a typical thread event variable that is used to notify a calling function when the initialization channel has been properly set up.

```
#
# Client Init: Initialize client session
#    stub: GRPC stub
#
def client_init(stub, event):
    #
    # Create SLInitMsg to handshake the version number with the server.
    # The Server will allow/deny access based on the version number.
    # The same RPC is used to setup a notification channel for global
    # events coming from the server.
    #
    # # Set the client version number based on the current proto files' version
    init_msg = sl_global_pb2.SLInitMsg()
    init_msg.MajorVer = sl_version_pb2.SL_MAJOR_VERSION
    init_msg.MinorVer = sl_version_pb2.SL_MINOR_VERSION
    init_msg.SubVer = sl_version_pb2.SL_SUB_VERSION

```
As shown above, `sl_global_pb2.SLInitMsg()` is the Init Msg object that must contain matching version fields before connecting to the router over gRPC.  
`SL_MAJOR_VERSION`, `SL_MINOR_VERSION` and `SL_SUB_VERSION` are defined in `sl_version.proto` and can be safely used to match the current version used by the gRPC server on the router.  

Next, set up a large timeout (since we want the initialization channel to stay up), before using the service-layer Global RPC: `SLGlobalInitNotif` to start the initialization channel.  The Init Message set up above and the `Timeout` values are passed in as parameters to the RPC.  

```
    # Set a very large timeout, as we will "for ever" loop listening on
    # notifications from the server
    Timeout = 365*24*60*60 # Seconds

```

The responses will be periodically received throughout the lifecycle (=`Timeout`) of this connection and hence we loop through them using a `for` loop:

```
    # This for loop will never end unless the server closes the session
    for response in stub.SLGlobalInitNotif(init_msg, Timeout):
        if response.EventType == sl_global_pb2.SL_GLOBAL_EVENT_TYPE_VERSION:
            if (sl_common_types_pb2.SLErrorStatus.SL_SUCCESS ==
                    response.ErrStatus.Status) or \
                (sl_common_types_pb2.SLErrorStatus.SL_INIT_STATE_CLEAR ==
                    response.ErrStatus.Status) or \
                (sl_common_types_pb2.SLErrorStatus.SL_INIT_STATE_READY ==
                    response.ErrStatus.Status):
                print("Server Returned 0x%x, Version %d.%d.%d" %(
                    response.ErrStatus.Status,
                    response.InitRspMsg.MajorVer,
                    response.InitRspMsg.MinorVer,
                    response.InitRspMsg.SubVer))
                print("Successfully Initialized, connection established!")
                # Any thread waiting on this event can proceed
                event.set()
            else:
                print("client init error code 0x%x", response.ErrStatus.Status)
                os._exit(0)
        elif response.EventType == sl_global_pb2.SL_GLOBAL_EVENT_TYPE_HEARTBEAT:
            print("Received HeartBeat")
        elif response.EventType == sl_global_pb2.SL_GLOBAL_EVENT_TYPE_ERROR:
            if (sl_common_types_pb2.SLErrorStatus.SL_NOTIF_TERM ==
                    response.ErrStatus.Status):
                print("Received notice to terminate. Client Takeover?")
                os._exit(0)
            else:
                print("Error not handled:", response)
        else:
            print("client init unrecognized response %d", response.EventType)
            os._exit(0)

```

As shown above, each response contains an EventType code (SLGlobalNotifType) and the different EventType codes can be utilized to process the responses received from the router. To learn more about the EventType codes, either check out the proto file: `sl_global.proto` or look at the generated documentation (from the .proto file), hosted on xrdocs:    

 ><https://xrdocs.io/cisco-service-layer/apidocs/group__SLGlobal.html#ga1d1b4192ce3a6703d905d8babb38e3a6>  

If the EventType is `SL_GLOBAL_EVENT_TYPE_VERSION` and the corresponding error code of the response is `SL_SUCCESS` or `SL_INIT_STATE_CLEAR` or `SL_INIT_STATE_READY`, then we set the `event` variable to notify callers that the initial connection was successful.
You can learn more about the error codes here:  

><https://xrdocs.io/cisco-service-layer/apidocs/group__SLCommonTypes.html#structSLErrorStatus>


Next, we package up the call to the `client_init` function above in another `global_thread` function so that if `client_init` exits, we can take appropriate action. For this demo code, we simply exit if `client_init` fails.    

```
#
# Thread starting point
#
def global_thread(stub, event):
    print("Global thread spawned")

    # Initialize the GRPC session. This function should never return
    client_init(stub, event)

    print("global_thread: exiting unexpectedly")
    # If this session is lost, then most likely the server restarted
    # Typically this is handled by reconnecting to the server. For now, exit()
    os._exit(0)

```    

This `global_thread` function is what we will invoke as a thread in our code. This packaging is optional and you could invoke the client_init code directly as a thread.  


### Set up the Thread for initialization

Now that we've set up the groundwork for the Client Initialization channel setup, let's start it as a thread. The relevant code is shown below.

The parameter `channel` passed in is the gRPC channel object we will create in the `main` function. The same gRPC channel will be utilized across all the `stubs` we create.    

```
#
# Spawn a thread for global events
#
def global_init(channel):

```

Note the creation of the gRPC stub using `SLGlobalStub` from `sl_global_pb2_grpc.py` binding and the `channel` object. This stub along with the event variable (`threading.Event()`) is passed into the `client_init` function described earlier.    

```
    # Create the gRPC stub.
    stub = sl_global_pb2_grpc.SLGlobalStub(channel)

    # Create a thread sync event. This will be used to order thread execution
    event = threading.Event()
```

Next, we start the  `global_thread` function described above as a thread, allowing the rest of the code to continue. The `stub` and `event` variables are passed in as arguments to the thread.  

```
    # The main reason we spawn a thread here, is that we dedicate a GRPC
    # channel to listen on Global asynchronous events/notifications.
    # This thread will be handling these event notifications.
    t = threading.Thread(target = global_thread, args=(stub, event))
    t.start()

```


The `event.wait()` call allows the code to wait for the event variable to be set inside the thread(described earlier, when the initialization channel is successfully set up).

```
    # Wait for the spawned thread before proceeding
    event.wait()
```


```
    # Get the globals. Create a SLGlobalsGetMsg
    global_get = sl_global_pb2.SLGlobalsGetMsg()

```  

Once the event variable is set, we fetch Service-Layer Global limits using the `SLGlobalsGetMsg` RPC. This is optional and only showcases how you make your first RPC call to fetch information over the existing gRPC connection.  

Again, utilize the stub (`SLGlobalStub`) to execute the RPC and process the error code in the response to dump the Global limits requested. We utilize a `Timeout=10` seconds - this is arbritary, the actual will be much faster.

```
    #
    # Make an RPC call to get global attributes
    #
    Timeout = 10 # Seconds
    response = stub.SLGlobalsGet(global_get, Timeout)
```

Finally, process the received response, and if the response error code indicates success (`SL_SUCCESS`), then print the response data as shown below:  


```
    # Check the received result from the Server
    if (response.ErrStatus.Status ==
        sl_common_types_pb2.SLErrorStatus.SL_SUCCESS):
        print("Max VRF Name Len     : %d" %(response.MaxVrfNameLength))
        print("Max Iface Name Len   : %d" %(response.MaxInterfaceNameLength))
        print("Max Paths per Entry  : %d" %(response.MaxPathsPerEntry))
        print("Max Prim per Entry   : %d" %(response.MaxPrimaryPathPerEntry))
        print("Max Bckup per Entry  : %d" %(response.MaxBackupPathPerEntry))
        print("Max Labels per Entry : %d" %(response.MaxMplsLabelsPerPath))
        print("Min Prim Path-id     : %d" %(response.MinPrimaryPathIdNum))
        print("Max Prim Path-id     : %d" %(response.MaxPrimaryPathIdNum))
        print("Min Bckup Path-id    : %d" %(response.MinBackupPathIdNum))
        print("Max Bckup Path-id    : %d" %(response.MaxBackupPathIdNum))
        print("Max Remote Bckup Addr: %d" %(response.MaxRemoteAddressNum))
    else:
        print("Globals response Error 0x%x" %(response.ErrStatus.Status))
        os._exit(0)

```

<p style="margin: 2em 0!important;padding: 1em;font-family: CiscoSans,Arial,Helvetica,sans-serif;font-size: 1em !important;text-indent: initial;background-color: #eff9ef;border-radius: 5px;box-shadow: 0 1px 1px rgba(0,127,171,0.25);">Great! At this stage you have learnt how to initialize the client connection and set up the Initialization Channel persistently within a thread. This is required to be accomplished before trying to register and utilize any specific functionality vertical.
</p>  



### IPv4 Route Vertical: Registration  

Before we can use the Route vertical's RPCs, we must register first. For the Route vertical this implies registering for a particular vrf and setting up some optional default attributes as shown below. Of course, it is possible to register for multiple VRFs at the same time.   

The input to the `vrf_operation` is a `channel` variable. This is the common gRPC channel that we will set up in the `main` function.    

```
def vrf_operation(channel, oper):

```

The first step is to again create a `stub`, this time using `SLRoutev4OperStub` utility in the Route Vertical specific binding: `sl_route_ipv4_pb2_grpc.py`.  

```
# Create the gRPC stub.
stub = sl_route_ipv4_pb2_grpc.SLRoutev4OperStub(channel)

```

The Registration message object (`SLVrfRegMsg`) contains a list of `SLVrfReg` objects allowing the registration for multiple vrfs:

```
# Create the SLVrfRegMsg message used for VRF registrations
vrfMsg = sl_route_common_pb2.SLVrfRegMsg()

# Create a list to maintain the SLVrfReg objects (in case of batch VRF
# registrations)
# In this example, we fill in only a single SLVrfReg object
vrfList = []

# Create an SLVrfReg object and set its attributes
vrfObj = sl_route_common_pb2.SLVrfReg()
```

Each `SLVrfReg` object contains the following fields:  

*  `VrfName` (in this case, set to `default`)

  ```
  # Set VRF name.
  vrfObj.VrfName = 'default'

  ```  

*  `AdminDistance`: The default admin-distance to be used for all routes in that vrf

  ```
  # Set Administrative distance
  vrfObj.AdminDistance = 2

  ```

*  `VrfPurgeIntervalSeconds`: The purge interval defines the amount of time that routes added by this client must be preserved in the VRF's routing table after the client gets disconnected or dies for some reason.

  ```
  # Set VRF purge interval
  vrfObj.VrfPurgeIntervalSeconds = 500

  ```  

The list of vrf objects are then appended to a list and added to `VrfRegMsgs` list inside the `vrfMsg` created above.

```
#
# Add the registration message to the list
# In case of bulk, we can append other VRF objects to the list
vrfList.append(vrfObj)

# Now that the list is completed, assign it to the SLVrfRegMsg
vrfMsg.VrfRegMsgs.extend(vrfList)

```

The `Oper` attribute is  the type of Registration operation to be performed. The options are described in the enum `SLRegOp` available in `sl_common_types.proto`. These are:

* SL_REGOP_REGISTER : Register against the vertical
* SL_REGOP_UNREGISTER : Remove registration for the vertical
* SL_REGOP_EOF :  Flush out stale entries, enabling a resync.

```
# Set the Operation
vrfMsg.Oper = oper

```

Finally, make the RPC call with a timeout of choice (we choose 10 seconds arbitrarily, the actual call will be much faster):

```
#
# Make an RPC call
#
Timeout = 10 # Seconds
response = stub.SLRoutev4VrfRegOp(vrfMsg, Timeout)

```

Process the received result and error codes to take appropriate action. Here, we simply print the response and its contents:  

```
#
# Check the received result from the Server
#
if (response.StatusSummary.Status ==
        sl_common_types_pb2.SLErrorStatus.SL_SUCCESS):
    print("VRF %s Success!" %(
        list(sl_common_types_pb2.SLRegOp.keys())[oper]))
else:
    print("Error code for VRF %s is 0x%x! Response:" % (
        list(sl_common_types_pb2.SLRegOp.keys())[oper],
        response.StatusSummary.Status
    ))
    print(response)
    # If we have partial failures within the batch, let's print them
    if (response.StatusSummary.Status ==
        sl_common_types_pb2.SLErrorStatus.SL_SOME_ERR):
        for result in response.Results:
            print("Error code for %s is 0x%x" %(result.VrfName,
                result.ErrStatus.Status
            ))
    os._exit(0)


```



### IPv4 Route Vertical: Objects and RPC Setup    


With the Registration complete, it is time to create Route objects that we intend to push into the IOS-XR RIB.

Create a gRPC stub using `SLRoutev4OperStub` from the `sl_route_ipv4_pb2_grpc.py` binding and the gRPC channel passed into the function. Again, this is the common gRPC channel we will create subsequently.  



```
#
# Route operations
#    channel: GRPC channel
#    oper: sl_common_types_pb2.SL_OBJOP_XXX
#
# A SLRoutev4Msg contains a list of SLRoutev4 (routes)
# Each SLRoutev4 (route) contains a list of SLRoutePath (paths)
#
def route_operation(channel, oper):
    # Create the gRPC stub.
    stub = sl_route_ipv4_pb2_grpc.SLRoutev4OperStub(channel)

```  

Now let's start populating the Route Message (`SLRoutev4Msg`) that will contain the route batch we intend to push to the IOS-XR RIB of router `r1`.  

The `SLRoutev4Msg` object is defined in `sl_route_ipv4.proto`. It contains the following elements:  

```
    # Create an empty list of routes.
    routeList = []

    # Create the SLRoutev4Msg message holding the SLRoutev4 object list
    rtMsg = sl_route_ipv4_pb2.SLRoutev4Msg()

```

* `VrfName` : must match the vrf name we registered for in the `vrf_operation` function above.    

  ```
  # Fill in the message attributes attributes.
  # VRF Name
  rtMsg.VrfName = 'default'
  ```  

* `Routes`: This is a list of `SLRoutev4` objects and represents the Route batch. Each `SLRoutev4` object in turn contains the following attributes (all defined in `sl_route_ipv4.proto`):  

  ```
  # Fill in the routes
  for i in range(10):
      #
      # Create an SLRoutev4 object and set its attributes
      #
      route = sl_route_ipv4_pb2.SLRoutev4()
  ```  

    * `Prefix`: 32 bit IPv4 prefix.  

      ```
      # IP Prefix
      route.Prefix = (
          int(ipaddress.ip_address('20.0.'+ str(i) + '.0'))
      )
      ```  

    * `PrefixLen`: 32 bit Prefix Length.  

      ```
      # Prefix Length
      route.PrefixLen = 24
      ```

    * `RouteCommon`: defined in `sl_route_common.proto` and consists of attributes such as `AdminDistance`, `LocalLabel` (for setting up MPLS ILM entry with a corresponding route in RIB), and a `tag` (which can be utilized during redistribution of the route between protocols). We only utilize and set the  `AdminDistance` here.

      ```
      # Administrative distance
      route.RouteCommon.AdminDistance = 2

      ```

    * `PathList`: a list of path objects. Each Path object is a combination of a `NexthopAddress` and `NexthopInterface`. Notice the `paths.append(path)` calls which add the `path` objects one by one to the `paths` list object before we extend (or assign) it to the `PathList` object:

      ```
      #
      # Set the route's paths.
      # A Route might have one or many paths
      #
      # Create an empty list of paths as a placeholder for these paths
      paths = []

      # Create an SLRoutePath path object.
      path = sl_route_common_pb2.SLRoutePath()
      # Fill in the path attributes.
      # Path next hop address
      path.NexthopAddress.V4Address = (
          int(ipaddress.ip_address('10.10.10.1'))
      )
      # Next hop interface name
      path.NexthopInterface.Name = 'GigabitEthernet0/0/0/0'

      #
      # Add the path to the list
      #
      paths.append(path)

      # Let's create another path as equal cost multi-path (ECMP)
      path = sl_route_common_pb2.SLRoutePath()
      path.NexthopAddress.V4Address = (
          int(ipaddress.ip_address('10.10.10.2'))
      )
      path.NexthopInterface.Name = 'GigabitEthernet0/0/0/0'

      #
      # Add the path to the list
      #
      paths.append(path)

      #
      # Assign the paths to the route object
      # Note: Route Delete operations do not require the paths
      #
      if oper != sl_common_types_pb2.SL_OBJOP_DELETE:
          route.PathList.extend(paths)

      ```

      Of course, for `SL_OBJOP_DELETE` operation, we will skip setting up the `PathList` since we only need the `Prefix` and `PrefixLen` attributes to delete a route.  

  Next, append the route created above and add to the `routeList` list object that we then extend(assign) to the `Routes` object in `rtMsg`.

  ```
    #
    # Append the route to the route list (bulk routes)
    #
    routeList.append(route)

    #
    # Done building the routeList, assign it to the route message.
    #
    rtMsg.Routes.extend(routeList)
  ```



* `Oper`: The types of operations are defined with `SLObjectOp` in `sl_common_types.proto` and are also described below:
    * `SL_OBJOP_ADD`: Add a route batch specified in the `SLRoutev4Msg` object. **This Operation is only meant for net-new routes and will fail if the any route within the route batch already exists in the RIB**
    * `SL_OBJOP_UPDATE`:  Update a route batch specified in the `SLRoutev4Msg` object and create a new route for each route in the route batch that doesn't already exist in the RIB.
    * `SL_OBJOP_DELETE`: Delete the routes specified in the Route batch.

  ```
  rtMsg.Oper = oper # Desired ADD, UPDATE, DELETE operation
  ```

Now make the RPC call over the `SLRoutev4OperStub` created above. We again use an arbritary `Timeout=10 seconds`.

  ```  
      #
      # Make an RPC call
      #
      Timeout = 10 # Seconds

      response = stub.SLRoutev4Op(rtMsg, Timeout)

  ```

Finally, check the received result from the router to determine if the route Operation was successful.

```
    #
    # Check the received result from the Server
    #
    if (sl_common_types_pb2.SLErrorStatus.SL_SUCCESS ==
            response.StatusSummary.Status):
        print("Route %s Success!" %(
            list(sl_common_types_pb2.SLObjectOp.keys())[oper]))
    else:
        print("Error code for route %s is 0x%x" % (
            list(sl_common_types_pb2.SLObjectOp.keys())[oper],
            response.StatusSummary.Status
        ))
        # If we have partial failures within the batch, let's print them
        if (response.StatusSummary.Status ==
            sl_common_types_pb2.SLErrorStatus.SL_SOME_ERR):
            for result in response.Results:
                print("Error code for %s/%d is 0x%x" %(
                    str(ipaddress.ip_address(result.Prefix)),
                    result.PrefixLen,
                    result.ErrStatus.Status
                ))
        os._exit(0)

```



### Invoking the Utilities  


Now that we have set up all the utilities:

*  `client_init`: To help set up the initialization channel

*  `global_init` and `global_thread`: To set up the groundwork to run `client_init` inside a thread so that it continues to persist while the rest of the code executes

*  `vrf_operation`: To register against the Route vertical for a given vrf(or a set of vrfs).  

*  `route_operation`: To construct the list Route Objects that must be manipulated (ADD, UPDATE, DELETE) in the IOS-XR RIB.  

We go ahead and invoke them one by one:


Use the `get_server_ip_port` utility described earlier to accept the SERVER_IP and SERVER_PORT environment variables as values into the `server_ip` and `server_port` variables.  

```
#
# Setup the GRPC channel with the server, and issue RPCs
#
if __name__ == '__main__':
    server_ip, server_port = get_server_ip_port()

    print("Using GRPC Server IP(%s) Port(%s)" %(server_ip, server_port))

```

Next, set up the gRPC channel that gets utilized across all the utilities described above. This channel can be TLS based (encrypted) or insecure. We showcase the example with an insecure channel. If you'd like to set up an encrypted channel, take a look at documentation up at <https://grpc.io>.  
We will add more examples on <https://xrdocs.io/cisco-service-layer/> shortly to showcase encrypted connections as well.   

```
    # Create the channel for gRPC.
    channel = grpc.insecure_channel(str(server_ip) + ":" + str(server_port))
```

Start the Initialization channel thread using the `global_init` utility.

```
    # Spawn a thread to Initialize the client and listen on notifications
    # The thread will run in the background
    global_init(channel)
```

Call the `vrf_operation` utility with the gRPC channel and the `SL_REGOP_REGISTER` operation to register against the Route vertical for `default` vrf.  This also marks any existing routes in the IOS-XR RIB (mark action as part of the Mark-and-sweep Garbage collection algorithm).
We also send a subsequent `SL_REGOP_EOF` to flush out any stale routes (sweep action) in the vrf from an earlier client or connection.

```
    # Send an RPC for VRF registrations
    vrf_operation(channel, sl_common_types_pb2.SL_REGOP_REGISTER)

    # RPC EOF to cleanup any previous stale routes
    vrf_operation(channel, sl_common_types_pb2.SL_REGOP_EOF)
```

Finally, play around with the Route Operations that you'd like to perform: `SL_OBJOP_ADD` is shown below. You would also notice `SL_OBJOP_DELETE` as commented out code.

<p style="margin: 2em 0!important;padding: 1em;font-family: CiscoSans,Arial,Helvetica,sans-serif;font-size: 1em !important;text-indent: initial;background-color: #e6f2f7;border-radius: 5px;box-shadow: 0 1px 1px rgba(0,127,171,0.25);">**Note**: If you uncomment the `SL_OBJOP_DELETE` call below - the code will add a route batch and then remove it.
</p>

```
    # RPC route operations
    #    for add: sl_common_types_pb2.SL_OBJOP_ADD
    #    for update: sl_common_types_pb2.SL_OBJOP_UPDATE
    #    for delete: sl_common_types_pb2.SL_OBJOP_DELETE
    route_operation(channel, sl_common_types_pb2.SL_OBJOP_ADD)

    #route_operation(channel, sl_common_types_pb2.SL_OBJOP_DELETE)
    # while ... add/update/delete routes

    # When done with the VRFs, RPC Delete Registration
    #vrf_operation(channel, sl_common_types_pb2.SL_REGOP_UNREGISTER)

    # Exit and Kill any running GRPC threads.
    os._exit(0)
```


### Running the code

Let's run the code and see the effects on the router, along with some show outputs:

```
admin@devbox:tutorial$ export SERVER_IP=10.10.20.170
admin@devbox:tutorial$ export SERVER_PORT=57021
admin@devbox:tutorial$
admin@devbox:tutorial$ python3 route.py
Using GRPC Server IP(10.10.20.170) Port(57021)
Global thread spawned
Server Returned 0x502, Version 0.0.0
Successfully Initialized, connection established!
Max VRF Name Len     : 33
Max Iface Name Len   : 64
Max Paths per Entry  : 64
Max Prim per Entry   : 32
Max Bckup per Entry  : 32
Max Labels per Entry : 3
Min Prim Path-id     : 1
Max Prim Path-id     : 64
Min Bckup Path-id    : 65
Max Bckup Path-id    : 128
Max Remote Bckup Addr: 2
VRF SL_REGOP_REGISTER Success!
VRF SL_REGOP_EOF Success!
Route SL_OBJOP_ADD Success!
admin@devbox:tutorial$

```

Hop onto the router `r1` and dump `show route`  


<p style="margin: 2em 0!important;padding: 1em;font-family: CiscoSans,Arial,Helvetica,sans-serif;font-size: 1em !important;text-indent: initial;background-color: #e6f2f7;border-radius: 5px;box-shadow: 0 1px 1px rgba(0,127,171,0.25);">**Username**: admin<br/>**Password**: admin<br/>**SSH port**: 2221
</p>  


```
RP/0/RP0/CPU0:r1#show  route
Sun Sep  2 16:53:58.119 UTC

Codes: C - connected, S - static, R - RIP, B - BGP, (>) - Diversion path
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP
       i - ISIS, L1 - IS-IS level-1, L2 - IS-IS level-2
       ia - IS-IS inter area, su - IS-IS summary null, * - candidate default
       U - per-user static route, o - ODR, L - local, G  - DAGR, l - LISP
       A - access/subscriber, a - Application route
       M - mobile route, r - RPL, t - Traffic Engineering, (!) - FRR Backup path

Gateway of last resort is 192.168.122.1 to network 0.0.0.0

S*   0.0.0.0/0 [1/0] via 192.168.122.1, 6d05h
a    20.0.0.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.1.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.2.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.3.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.4.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.5.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.6.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.7.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.8.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
a    20.0.9.0/24 [2/0] via 10.10.10.1, 00:01:17, GigabitEthernet0/0/0/0
                 [2/0] via 10.10.10.2, 00:01:17, GigabitEthernet0/0/0/0
C    192.168.122.0/24 is directly connected, 6d05h, MgmtEth0/RP0/CPU0/0
L    192.168.122.21/32 is directly connected, 6d05h, MgmtEth0/RP0/CPU0/0
RP/0/RP0/CPU0:r1#

```

The `a` routes are the routes we intended to push as part of the `route_operation` utility described earlier.


#### Understanding Mark-and-Sweep with Registration Operations


Let's check out some of the `service-layer` show commands post the last run of the client code.

* `show  service-layer vrf <>`: Showcases the objects set as part of the Route Vertical registration for the vrf (or set of vrfs). Since we did not `UNREGISTER` as part of the code, this registration persists even after the client disconnects.  

  ```
  RP/0/RP0/CPU0:r1#show  service-layer vrf default
  Sun Sep  2 16:57:42.689 UTC
  vrf name: default,  vrf afi: IPv4,  vrf state: eof,
  vrf magic: valid,  vrf purge time: 500,  vrf admin distance: 2,
  vrf flags: eof ,

  RP/0/RP0/CPU0:r1#

  ```

* `show  service-layer route `: Showcases the routes objects that were added by our client. Notice the `magic` field in each route object. These routes are all marked `valid`.

  ```
    RP/0/RP0/CPU0:r1#
    RP/0/RP0/CPU0:r1#show  service-layer route      
    Sun Sep  2 16:59:45.923 UTC
    prefix: 20.0.0.0/24, tag: 0, distance: 2, magic: valid,
        path: 1,
            id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
            magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
            next hop: 10.10.10.1,
        path: 2,
            id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
            magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
            next hop: 10.10.10.2,
    prefix: 20.0.1.0/24, tag: 0, distance: 2, magic: valid,
        path: 1,
            id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
            magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
            next hop: 10.10.10.1,
        path: 2,
            id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
            magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,

  ......................# Snipped Output #........................  
  ```


Now let's mark these routes as stale. For this purpose, we will simply Register using the client again but will not send an EOF or any route object. For this purpose, modify the `main` function to something like shown below (notice the commented out code with # marked in yellow)

<p><pre><code>
if __name__ == '__main__':
    server_ip, server_port = get_server_ip_port()

    print("Using GRPC Server IP(%s) Port(%s)" %(server_ip, server_port))

    # Create the channel for gRPC.
    channel = grpc.insecure_channel(str(server_ip) + ":" + str(server_port))

    # Spawn a thread to Initialize the client and listen on notifications
    # The thread will run in the background
    global_init(channel)

    # Send an RPC for VRF registrations
    vrf_operation(channel, sl_common_types_pb2.SL_REGOP_REGISTER)

    # RPC EOF to cleanup any previous stale routes
    <mark>#vrf_operation(channel, sl_common_types_pb2.SL_REGOP_EOF)</mark>

    # RPC route operations
    #    for add: sl_common_types_pb2.SL_OBJOP_ADD
    #    for update: sl_common_types_pb2.SL_OBJOP_UPDATE
    #    for delete: sl_common_types_pb2.SL_OBJOP_DELETE
    <mark>#route_operation(channel, sl_common_types_pb2.SL_OBJOP_ADD)</mark>

    #route_operation(channel, sl_common_types_pb2.SL_OBJOP_DELETE)
    # while ... add/update/delete routes

    # When done with the VRFs, RPC Delete Registration
    #vrf_operation(channel, sl_common_types_pb2.SL_REGOP_UNREGISTER)

    # Exit and Kill any running GRPC threads.
    os._exit(0)

</code></pre></p>

Running again:  

```

admin@devbox:tutorial$ python3 route.py
Using GRPC Server IP(10.10.20.170) Port(57021)
Global thread spawned
Server Returned 0x502, Version 0.0.0
Successfully Initialized, connection established!
Max VRF Name Len     : 33
Max Iface Name Len   : 64
Max Paths per Entry  : 64
Max Prim per Entry   : 32
Max Bckup per Entry  : 32
Max Labels per Entry : 3
Min Prim Path-id     : 1
Max Prim Path-id     : 64
Min Bckup Path-id    : 65
Max Bckup Path-id    : 128
Max Remote Bckup Addr: 2
VRF SL_REGOP_REGISTER Success!
admin@devbox:tutorial$

```

Great, now check the `show service-layer route` command again. Notice the `magic` field in each route has been marked `stale`. This is the `Mark` operation described as part of the mark-and-sweep functionality associated with the registration calls.


```
RP/0/RP0/CPU0:r1#show  service-layer route
Sun Sep  2 17:05:24.335 UTC
prefix: 20.0.0.0/24, tag: 0, distance: 2, magic: valid, flags: stale ,
    path: 1,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.1,
    path: 2,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.2,
prefix: 20.0.1.0/24, tag: 0, distance: 2, magic: valid, flags: stale ,
    path: 1,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.1,
    path: 2,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.2,
prefix: 20.0.2.0/24, tag: 0, distance: 2, magic: valid, flags: stale ,
    path: 1,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.1,
    path: 2,
        id: 0, flags: 0, protected bitmap: 0x0, metric: 0, ref count: 10,
        magic: valid, load metric: 0, interface name: GigabitEthernet0/0/0/0,
        next hop: 10.10.10.2,


......................# Snipped Output #........................

```

To flush out these routes (to perform the `sweep` operation of the Mark-and-sweep) , uncomment only the `SL_REGOP_EOF` code, keep the route operations commented out.
(changes required highlighted in yellow):  


<p><pre><code>
if __name__ == '__main__':
    server_ip, server_port = get_server_ip_port()

    print("Using GRPC Server IP(%s) Port(%s)" %(server_ip, server_port))

    # Create the channel for gRPC.
    channel = grpc.insecure_channel(str(server_ip) + ":" + str(server_port))

    # Spawn a thread to Initialize the client and listen on notifications
    # The thread will run in the background
    global_init(channel)

    # Send an RPC for VRF registrations
    vrf_operation(channel, sl_common_types_pb2.SL_REGOP_REGISTER)

    # RPC EOF to cleanup any previous stale routes
    <mark>vrf_operation(channel, sl_common_types_pb2.SL_REGOP_EOF)</mark>

    # RPC route operations
    #    for add: sl_common_types_pb2.SL_OBJOP_ADD
    #    for update: sl_common_types_pb2.SL_OBJOP_UPDATE
    #    for delete: sl_common_types_pb2.SL_OBJOP_DELETE
    #route_operation(channel, sl_common_types_pb2.SL_OBJOP_ADD)

    #route_operation(channel, sl_common_types_pb2.SL_OBJOP_DELETE)
    # while ... add/update/delete routes

    # When done with the VRFs, RPC Delete Registration
    #vrf_operation(channel, sl_common_types_pb2.SL_REGOP_UNREGISTER)

    # Exit and Kill any running GRPC threads.
    os._exit(0)

</code></pre></p>

Run the code again:  

```
admin@devbox:tutorial$ python3 route.py
Using GRPC Server IP(10.10.20.170) Port(57021)
Global thread spawned
Server Returned 0x502, Version 0.0.0
Successfully Initialized, connection established!
Max VRF Name Len     : 33
Max Iface Name Len   : 64
Max Paths per Entry  : 64
Max Prim per Entry   : 32
Max Bckup per Entry  : 32
Max Labels per Entry : 3
Min Prim Path-id     : 1
Max Prim Path-id     : 64
Min Bckup Path-id    : 65
Max Bckup Path-id    : 128
Max Remote Bckup Addr: 2
VRF SL_REGOP_REGISTER Success!
VRF SL_REGOP_EOF Success!
admin@devbox:tutorial$

```

Finally, dump the `show service-layer route` output again:


```
RP/0/RP0/CPU0:r1#show  service-layer route
Sun Sep  2 17:09:56.495 UTC
RP/0/RP0/CPU0:r1#
RP/0/RP0/CPU0:r1#
RP/0/RP0/CPU0:r1#

```

And the routes were flushed out (Sweep)!

When a client (or controller) that is responsible for syncing routes into the IOS-XR RIB either dies or gets disconnected, then the routes that may have been manipulated during the last run may not be reliable. In such situations, it is important to re-sync routes from your controller/client by flushing out existing ones and replaying routes from the controller's internal RIB. This is where this mark and sweep capability becomes super useful.


#### Wrapping up

Finally, play around with different Operations (`SL_OBJOP_ADD`, `SL_OBJOP_DELETE`, `SL_OBJOP_UPDATE`) to see how the IOS-XR RIB state responds based on your client code. We leave this as an exercise for the reader. Happy coding!


<p style="margin: 2em 0!important;padding: 1em;font-family: CiscoSans,Arial,Helvetica,sans-serif;font-size: 1em !important;text-indent: initial;background-color: #eff9ef;border-radius: 5px;box-shadow: 0 1px 1px rgba(0,127,171,0.25);">Phew! That was a long lab. But in the end, you were able to learn the basics of the Service-layer API proto files, how to set up your environment, how to generate bindings from the proto files, execute and observe the effects of existing tutorials before diving deep into the code of a service-layer API python client. Use this knowledge to start writing your own clients and controllers that can help manipulate the network infrastructure layer (Service Layer) state of your IOS-XR router.
</p>  
